"""
풀이 시간: 1시간 30분
- D[x+3] - D[x]를 빼서 D[x] 점화식을 구해주는 아이디어 참고

<input>
n : 가로 길이 (1 ≤ n ≤ 100,000)

<solution>
1. 테이블 정의하기
D[i] = i x 3 크기의 판을 타일링하는 방법의 수

2. 점화식 찾기
D[i] = D[i-1] + 2*D[i-2] + 6*D[i-3] + D[i-4] - D[i-6]

3. 초기값 정하기
D[1] = 1, D[2] = 3, D[3] = 10

<후기>
전형적인 DP문제로 백준의 2 x n 타일링 시리즈와 매우 비슷하지만 점화식을 도출하기 좀 더 까다롭다. (가장 비슷한 건, 프로그래머스의 3 x n 타일링 문제)
이 문제에서 중요한 점은 두 가지인데
1. n = 4, 5, 6일 때 완전히 새롭게 나타나는 타일링 방법의 수가 각각 2, 2, 4개 이며 이후 계속 2, 2, 4개가 반복해서 발생한다는 점을 캐치해야 한다.
2. 점화식을 도출할 때, D[x] = D[x-1] * s[1] + D[x-2] * s[2] + D[x-3] * s[3] + D[x-4] * s[4] + D[x-5] * s[5] + D[x-6] * s[6] + ... + s[x]에서 
s[4]부터 2, 2, 4가 반복되므로, D[x+3]를 사용해 중복되는 부분을 제거해야 한다. 
결과적으로 D[x+3] - D[x]를 해줌으로써 D[x]의 최종 점화식을 도출할 수 있게 된다.

처음에 1번까지는 생각했는데 S배열을 따로 만들어줘야 하나 고민을 하다가, 그렇게 되면 이중 for문이 돼 시간복잡도가 터지게 되고 어차피 S[4]부터 2, 2, 4가 반복되기 때문에 굳이 별도로 배열을 만들어 줄 필요가 없다는 점을 알았다.
이후에 D[x+3]에서 D[x]를 빼줄 생각은 못 했는데 새로운 부분을 배울 수 있었다.
"""
def solution(n):
    answer = 0
    d = [0] * 100001 # d[i]: i x 3 크기의 판을 타일링하는 방법의 수
    mod = 1000000007

    # 초기값 설정
    d[0] = 1
    d[1] = 1
    d[2] = 3
    d[3] = 10

    for i in range(4, n+1):
        # 점화식
        d[i] = d[i-1] + 2 * d[i-2] + 6 * d[i-3] + d[i-4] - d[i-6]
        d[i] %= mod

    answer = d[n]
    return answer


print(solution(9))

