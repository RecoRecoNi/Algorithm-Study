"""
풀이 시간: 5분

<input>
maps: n x m크기의 게임 맵의 상태가 들어있는 2차원 배열
- n과 m은 1이상 100이하의 자연수
- n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않는다.
- maps는 0(벽)과 1(벽이 없는 자리)로만 이루어져 있다.
- 처음 캐릭터는 좌상단 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단(n, m) 위치에 있다.

<solution>
BFS를 통해 시작점(1, 1)에서 도착점(n, m)까지의 최단 거리를 구할 수 있다.


<시간복잡도>
O(NM): 최악의 경우 모든 칸을 방문해야 한다.
"""
from collections import deque


def solution(maps):
    # 동서남북
    dx = [0, 0, 1, -1]
    dy = [1, -1, 0, 0]

    # 시작 위치는 (0, 0), 상대방 진영은 (n-1, m-1)
    n = len(maps) - 1
    m = len(maps[0]) - 1

    q = deque()
    q.append((0, 0))
    while q:
        x, y = q.popleft()
        for k in range(4):
            nx, ny = x+dx[k], y+dy[k]
            # 범위를 벗어나지 않으면서 벽이 없는 방문한 적이 없는 칸
            if 0 <= nx <= n and 0 <= ny <= m and maps[nx][ny] == 1:
                maps[nx][ny] = maps[x][y] + 1
                q.append((nx, ny))

    # 도착할 수 있는 경우 최단 거리, 도착할 수 없는 경우 -1을 반환
    return maps[n][m] if maps[n][m] != 1 else -1


# 테스트 케이스
test_case1 = [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]
test_case2 = [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]]

"""
정확성  테스트
테스트 1 〉	통과 (0.03ms, 10.3MB)
테스트 2 〉	통과 (0.03ms, 10.3MB)
테스트 3 〉	통과 (0.05ms, 10.3MB)
테스트 4 〉	통과 (0.04ms, 10.2MB)
테스트 5 〉	통과 (0.03ms, 10.2MB)
테스트 6 〉	통과 (0.07ms, 10.3MB)
테스트 7 〉	통과 (0.07ms, 10.2MB)
테스트 8 〉	통과 (0.04ms, 10.1MB)
테스트 9 〉	통과 (0.06ms, 10.2MB)
테스트 10 〉	통과 (0.05ms, 10.1MB)
테스트 11 〉	통과 (0.03ms, 10.2MB)
테스트 12 〉	통과 (0.03ms, 10.2MB)
테스트 13 〉	통과 (0.07ms, 10.2MB)
테스트 14 〉	통과 (0.04ms, 10.2MB)
테스트 15 〉	통과 (0.05ms, 10.1MB)
테스트 16 〉	통과 (0.02ms, 10.2MB)
테스트 17 〉	통과 (0.08ms, 10.3MB)
테스트 18 〉	통과 (0.01ms, 10.2MB)
테스트 19 〉	통과 (0.02ms, 10.1MB)
테스트 20 〉	통과 (0.01ms, 10.1MB)
테스트 21 〉	통과 (0.02ms, 10.2MB)

효율성  테스트
테스트 1 〉	통과 (11.17ms, 10.1MB)
테스트 2 〉	통과 (3.03ms, 10.2MB)
테스트 3 〉	통과 (8.18ms, 10.3MB)
테스트 4 〉	통과 (5.35ms, 10.2MB)
"""