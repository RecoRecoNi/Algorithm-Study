"""
풀이시간: 20분

<input>
- 자연수의 개수 n: 1 이상 10,000 이하의 자연수
- 모든 원소들의 합 s: 1 이상, 100,000,000 이하의 자연수

<solution>
- s가 최대 1억 -> 직접 모든 경우의 수를 구하는 것은 불가능
- 원소의 곱이 최대가 되려면 예제처럼 각 수들간의 차이가 작은 수들끼리 곱해야함
- n 제한이 1만개이기 때문에 n을 활용(또한, n이 자연수이기 때문에 항상 s가 n보다 커야함)

위 세가지 조건들을 생각하며 몇 가지 예제를 통해 공통점을 발견
- s//n를 시작점으로 n-(s%n)개
- (s//n)+1는 시작점으로 부터 (s%n)개

<시간복잡도>
O(n): 리스트 컴프리헨션을 통해 답을 도출하는 과정에서 발생
"""
from typing import List

def solution(n: int, s: int) -> List:
    if n > s: return [-1] # n은 자연수이기 때문에 s보다 크다면 조건에 만족하는 집합을 만들 수 없음
    start, remainder = divmod(s, n) # 시작점(몫), 나머지
    return [start] * (n-remainder) + [start+1] * remainder # 시작점은 (n-나머지)의 개수, 시작점+1은 나머지의 개수


"""
정확성  테스트
테스트 1 〉	통과 (0.03ms, 10.3MB)
테스트 2 〉	통과 (0.05ms, 10.3MB)
테스트 3 〉	통과 (0.05ms, 10.2MB)
테스트 4 〉	통과 (0.04ms, 10.4MB)
테스트 5 〉	통과 (0.01ms, 10.2MB)
테스트 6 〉	통과 (0.02ms, 10.3MB)
테스트 7 〉	통과 (0.01ms, 10.3MB)
테스트 8 〉	통과 (0.01ms, 10.3MB)
테스트 9 〉	통과 (0.03ms, 10.4MB)
테스트 10 〉통과 (0.06ms, 10.4MB)
테스트 11 〉통과 (0.05ms, 10.5MB)
테스트 12 〉통과 (0.03ms, 10.3MB)
테스트 13 〉통과 (0.05ms, 10.4MB)
테스트 14 〉통과 (0.00ms, 10.2MB)


효율성  테스트
테스트 1 〉	통과 (0.07ms, 10.5MB)
테스트 2 〉	통과 (0.07ms, 10.3MB)
테스트 3 〉	통과 (0.07ms, 10.5MB)
테스트 4 〉	통과 (0.09ms, 10.6MB)
테스트 5 〉	통과 (0.10ms, 10.7MB)
테스트 6 〉	통과 (0.00ms, 10.1MB)
"""