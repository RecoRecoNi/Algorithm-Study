"""
풀이시간: 25분

<input>
m: 가로의 크기(1 <= m <= 100, 자연수)
n: 세로의 크기(1 <= n <= 100, 자연수)
puddles: 물이 잠긴 지역의 좌표를 담은 2차원 배열(0개 이상 10개 이하)

<solution>
BFS인가? 싶었는데 우선 큰 수(1,000,000,007)로 경우의 수를 나누는걸 보면 DP라고 생각하고 접근

dp[i][j] = (i, j)칸까지 최단경로의 경우의 수 라고 한다면, 항상 오른쪽 또는 아래로만 이동하기 때문에
위에서 오는 경우의 수(dp[i-1][j]) + 오른쪽에서 오는 경우의 수(dp[i][j-1])가 dp[i][j]의 값이 될 수 있다.
이 때, 수가 너무 커지지 않게 하기 위해 항상 1,000,000,007로 나눈 나머지 수를 테이블에 기록한다.

<시간복잡도>
O(NM)

<번외>
puddles의 x,y가 다른 문제들과 달리 반대로 나와있어서 시간을 한참 썼다..😐
"""
from typing import List


def solution(m:int, n:int, puddles:List[List]) -> int:
    """
    m: 격자의 가로크기
    n: 격자의 세로크기
    puddles: 물이 잠긴 지역의 좌표
    """
    # dp테이블 초기화
    dp = [[0] * (m+1) for _ in range(n+1)]

    # 물에 잠긴 지역
    for x, y in puddles:
        dp[y][x] = -1

    # 시작칸(집) 경우의 수 초기화
    dp[1][1] = 1
    for i in range(1, n+1):
        for j in range(1, m+1):
            if dp[i][j] == -1: # 물에 잠겨 이동할 수 없는 칸
                dp[i][j] = 0 # 해당 칸으로는 갈 수 없음
            else: # 이동할 수 있는 경우
                dp[i][j] += (dp[i-1][j] + dp[i][j-1]) % 1000000007

    # 도착칸(학교)까지 최단 경로의 개수를 1,000,000,007로 나눈 나머지 반환
    return dp[n][m]

"""
정확성  테스트
테스트 1 〉	통과 (0.01ms, 10.7MB)
테스트 2 〉	통과 (0.01ms, 10.5MB)
테스트 3 〉	통과 (0.02ms, 10.5MB)
테스트 4 〉	통과 (0.03ms, 10.6MB)
테스트 5 〉	통과 (0.05ms, 10.4MB)
테스트 6 〉	통과 (0.06ms, 10.6MB)
테스트 7 〉	통과 (0.04ms, 10.5MB)
테스트 8 〉	통과 (0.08ms, 10.4MB)
테스트 9 〉	통과 (0.04ms, 10.5MB)
테스트 10 〉	통과 (0.02ms, 10.5MB)

효율성  테스트
테스트 1 〉	통과 (2.15ms, 10.6MB)
테스트 2 〉	통과 (0.87ms, 10.6MB)
테스트 3 〉	통과 (1.13ms, 10.6MB)
테스트 4 〉	통과 (1.59ms, 10.5MB)
테스트 5 〉	통과 (1.31ms, 10.5MB)
테스트 6 〉	통과 (2.30ms, 10.7MB)
테스트 7 〉	통과 (1.43ms, 10.7MB)
테스트 8 〉	통과 (1.83ms, 10.6MB)
테스트 9 〉	통과 (1.73ms, 10.7MB)
테스트 10 〉	통과 (1.66ms, 10.6MB)
"""