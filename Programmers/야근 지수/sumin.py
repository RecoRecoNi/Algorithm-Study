"""
풀이시간: 20분

<input>
- works: 길이 1 이상, 20,000 이하인 배열
- works의 원소는 50000 이하인 자연수
- n:  1,000,000 이하인 자연수

<solution>
a^2 + b^2 + ... + x^2이 최소가 되려면 계속해서 가장 작업량이 큰 수를 먼저 처리해야 함
예를 들어, [7, 8] 작업이 있다고 생각했을 때 당연하게도 8을 7로 줄이는 것이 야근 피로도가 최소가 되고
[7, 7]일 때는 어떤 것을 줄이든 상관없음. [7, 6]이 됐을 때는 다시 7을 6으로 줄이는 것이 야근 피로도를 최소화할 수 있게 됨
-> 이를 통해 항상 전체 작업 중 작업량이 가장 큰 값을 먼저 처리해야 됨을 알 수 있음
-> works의 길이가 최대 20,000이기 때문에 n번 max함수를 쓰면 시간초과가 나기 때문에 우선순위큐를 사용해서 최대값을 찾을 수 있음

<시간복잡도>
O(n): 최대 퇴근까지 남은 시간 n번만 확인하면 됨

"""
import heapq
from typing import List

def solution(n: int, works: List) -> int:
    heap = []
    for x in works: # 최대힙으로 구현(작업량이 가장 큰 값)
        heapq.heappush(heap, -x)
    for i in range(n): # 퇴근까지 남은 시간동안 반복
        if not heap: # 더 이상 작업량이 없으면 종료
            break
        max_num = -heapq.heappop(heap) # 가장 작업량이 큰 업무
        max_num -= 1 # 업무 처리
        if max_num != 0: # 여전히 작업량이 남은 일만 다시 힙에 추가
            heapq.heappush(heap, -max_num)
    answer = sum([(-work)**2 for work in heap]) # 야근 피로도 계산
    return answer

"""
정확성  테스트
테스트 1 〉	통과 (0.05ms, 10.2MB)
테스트 2 〉	통과 (0.01ms, 10.2MB)
테스트 3 〉	통과 (0.01ms, 10.4MB)
테스트 4 〉	통과 (0.07ms, 10.2MB)
테스트 5 〉	통과 (0.01ms, 10.3MB)
테스트 6 〉	통과 (0.01ms, 10.3MB)
테스트 7 〉	통과 (0.01ms, 10.2MB)
테스트 8 〉	통과 (0.48ms, 10.2MB)
테스트 9 〉	통과 (0.77ms, 10.3MB)
테스트 10 〉	통과 (0.01ms, 10.2MB)
테스트 11 〉	통과 (0.01ms, 10.2MB)
테스트 12 〉	통과 (0.01ms, 10.3MB)
테스트 13 〉	통과 (0.01ms, 10.2MB)

효율성  테스트
테스트 1 〉	통과 (418.78ms, 10.1MB)
테스트 2 〉	통과 (427.85ms, 10.2MB)
"""