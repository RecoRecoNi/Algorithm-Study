"""

풀이시간
- 1시간 풀이 후 실패로 답지 참조

접근법
- N 이 1000 이하 -> 최대 O(N^2) 으로 접근
- 부분수열은 계속해서 중첩됨 -> DP 를 활용해보자
- 두 문자열의 길이가 같지 않을 수 있음을 주의해야함

- 틀린 풀이
    - 멀리 떨어져있는 값들을 어떻게 조각처럼 붙힐 수 있을까 ..?
        - 부분수열을 찾을 때 조합을 활용할 수 있을 것 같음, 다만 시간복잡도...
        - 조합을 활용할 때 메모이제이션을 이용할 수 있을까..? -> 모르겠음
- 정답 풀이
    - 이중반복문을 활용하여 DP 테이블을 계산
    - 각 문자열을 순회하며 같은 문자를 확인
    - dp[i][j] 는 s1[0:i] 와 s2[0:j] 의 LCS 의 길이를 나타냄

회고
- 점화식에 대해서 너무 복잡하게 생각한 것 같음
    - 사전에 점화식에 대한 고민을 충분히 해보고, 도저히 모르겠으면 일단 저퀄(?)의 코드로 구현을 먼저한 후 메모이제이션을 활용해 개선하는 방안도 필요할 것 같다

"""

import sys

inputs = sys.stdin.readline
s1 = inputs().rstrip()
s2 = inputs().rstrip()

len_1, len_2 = len(s1), len(s2)

dp = [[0] * (len_2 + 1) for _ in range(len_1 + 1)] # DP 테이블 초기화

# 문자열을 한 문자씩 비교하면서 LCS 의 길이를 계산
for i in range(1, len_1 + 1):
    for j in range(1, len_2 + 1):
        if s1[i - 1] == s2[j - 1]: # 공통부분 수열을 만들 수 있다면 만들기 (+1)
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # 부분 수열을 만들 수 없다면 이전까지 기억한 부분수열 중 가장 긴것을 저장

print(dp[-1][-1])