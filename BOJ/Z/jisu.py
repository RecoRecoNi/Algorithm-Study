'''
풀이 시작 : 2023-08-17 22:30

2^15 x 2^15 테이블을 만드는 건 말이 안될 것 같고,

예를 들어 (3, 5, 2)가 들어온 경우 (38)

0 | 1
--|--     이라고 할 때
2 | 3 

2^3 x 2^3 기준 2 -> +32 (2^2 x 2^2 x (2))
그 안의 2^2 x 2^2 기준 1 -> + 4 (2^1 x 2^1 x (1))
그 안의 2^1 x 2^1 기준 2번째 -> +2 (2^0 x 2^0 x (2))

요런식으로 답을 구할 수 있을 것 같다. 일반화 해보자

2^n x 2^n 기준 2 -> (2^(n-1) x 2^(n-1) x 2) -> (4^(n-1) x 2)  요런 식으로!
즉, (4^(n-1) x 2) + 재귀(n-1, 조정된 r, c)  이렇게 재귀를 하면 되고, 최종적으로 N=1이 됐을 때
기저 조건을 반환하면 된다.

요런 식으로 풀면 시간 복잡도는 O(N)이 맞나..? N 이 15 to 1 까지 재귀하고 재귀의 시간 복잡도는 거의 상수니까?
첨에 너무 머리가 아팠는데, 작은 수를 대입해서 생각하니 실마리가 보였다.

풀이 완료 : 2023-08-17 23:30 (풀이시간 약 1시간)

'''

def solution() -> int:

    N, r, c = map(int, input().rstrip().split())

    def recur(N, r, c):             # 재귀함수

        if N == 1:                  # 기저 조건, Z 순서대로 반환
            if r == 0 and c == 0:
                return 0
            elif r == 0 and c == 1:
                return 1
            elif r == 1 and c == 0:
                return 2
            else:
                return 3

        if 0 <= r < 2**(N-1) and 0 <= c < 2**(N-1):             # 위치 0의 경우
            return recur(N-1, r, c)                                 # 그대로 재귀
        elif 0 <= r < 2**(N-1) and 2**(N-1) <= c < 2**N:        # 위치 1의 경우
            return 4**(N-1) + recur(N-1, r, c-(2**(N-1)))           # 해당 위치에서 (N-1, r, c)를 돌린다고 생각
        elif 2**(N-1) <= r < 2**N and 0 <= c < 2**(N-1):        # 다른 위치도 마찬가지
            return 2 * 4**(N-1) + recur(N-1, r-(2**(N-1)), c)       # r, c 인덱스와 곱해주는 배율만 위치에 맞게 조정하면 됨
        else:
            return 3 * 4**(N-1) + recur(N-1, r-(2**(N-1)), c-(2**(N-1)))

    return recur(N, r, c)

print(solution())

