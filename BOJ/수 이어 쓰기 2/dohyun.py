"""

풀이시간
- 약 1시간 30분 풀이 후 실패로 답지 참조

접근법
- N, K 가 억, 십억 -> What the ...?
- 구현 자체는 쉬워보이지만 시간복잡도 + 공간복잡도를 최대한으로 줄여야 함 
    - O(N)? O(logN)?
- 자료구조 등을 잘 활용하더라도 이 정도로 줄이긴 힘들 것 같음 -> 경우의수에 규칙이 있을 것 같다!

----- 10 단위수 -----
10 11 12 13 14 15 16 17 18 19 -> 10 * 2
20 ... 29 -> 10 * 2
~
90 ... 99 -> 10 * 2
총합 -> 10 * 2 * 9

----- 100 단위수 -----
100 101 ... 199 -> 100 * 3
~
900 901 ... 999 -> 100 * 3
총합 -> 100 * 3 * 9

- 즉 10 * X 단위수라면(X >= 1), 만들 수 있는 총 인덱스는 ((10**0)*1 * 9) + ((10**1)*2 * 9) + ... ((10**X)*(X+1) * 9)
- 그럼 X 는 어떻게 찾을 것인가? -> len(N)-1
- 그 다음 K 이전 인덱스들을 싹 다 빼고 N 도 10 * X 부터 시작하면 됨

```
def recursion(X):
    return 9 * sum(10**i * (i+1) for i in range(X))
```

- 그 과정에서 몫과 나머지를 적절히 이용하면 됨
- 라고 1시간 반동안 삽질하다가 계속 틀려서 확인해보니 완전 잘못 접근 ..ㅎ
    - N 이 아무리 큰 숫자라도 K 가 아주 작은 숫자라면 앞에를 버리는 순간 답이 나올수가 없음
    - 틀린 풀이를 첨부하려다가 아예 생각자체를 잘못한 것 같아서 그냥 첨부 안하겠습니다!

- 정답 풀이를 계속 읽어봤는데도 잘 모르겠네요 ㅠㅠ 스터디 시간에 집중해서 듣겠습니다..!

회고
- 나름대로 접근은 괜찮았던 것 같았는데 .. ㅠㅠ 계속 틀리니까 멘탈이 나가버린 것 같음
- 중간과정에서 출력 찍어보면서 잘못된 방향으로 접근한건 아닌지 디버깅 한번씩 해보고 넘어가기

"""

n, k = map(int, input().split())
ans = 0  # 최종 답을 저장하는 변수
digit = 1  # 현재 자릿수
nine = 9  # 현재 자릿수에서 가능한 숫자 범위

### 단위 수로 생각한 것과 유사
# k번째 자리 숫자가 현재 자릿수 범위 내에 있는지 확인
while k > digit * nine:
    k -= digit * nine  # k를 현재 자릿수 범위에서 빼줌
    ans += nine  # 가능한 숫자 범위를 더해줌
    digit += 1  # 다음 자릿수로 이동
    nine *= 10  # 다음 자릿수에서 가능한 숫자 범위 업데이트

# k번째 자리 숫자를 찾음
ans = (ans + 1) + (k - 1) // digit

# 찾은 숫자가 n을 초과하는 경우 -1 출력
if ans > n:
    print(-1)
else:
    # 찾은 숫자에서 k번째 자릿수를 구하고 출력
    print(str(ans)[(k - 1) % digit])
