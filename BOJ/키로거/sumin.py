"""
시간: 10분
에디터와 매우 유사한 문제로 스택 두개를 활용해 문제를 풀었다.

<solution>
- 문자열의 길이가 1,000,000이기 때문에 O(n)으로 해결해야 함
- 링크드 리스트에 속한 문제이고, 스택 두개를 이용해 링크드 리스트를 구현할 수 있기 때문에 링크드 리스트를 구현하기보다는 스택 역할로 list를 사용했다.
"""
import sys
input = sys.stdin.readline

t = int(input()) # 테스트 케이스의 개수
for _ in range(t):
    # 길이가 L인 문자열 입력(1 <= L <= 1,000,000)
    pw = input().rstrip() # 문자열에는 알파벳 대소문자, 숫자, 백스페이스, <, >가 온다.
    left = [] # 커서의 왼쪽
    right = [] # 커서의 오른쪽
    for s in pw: # 문자를 하나씩 확인하면서
        # 1) 백스페이스인 경우
        if s == '-':
            if left: # 커서의 왼쪽에 문자가 있다면
                left.pop() # 문자를 지움
        # 2) < 인 경우
        elif s == '<':
            if left: # 커서의 왼쪽에 문자가 있다면
                right.append(left.pop()) # 커서를 한 칸 왼쪽으로 이동 -> 즉, 커서의 한 칸 왼쪽에 있던 문자가 커서의 오른쪽으로 이동하게 됨
        # 3) > 인 경우
        elif s == '>':
            if right: # 커서의 오른쪽에 문자가 있다면
                left.append(right.pop()) # 커서를 한 칸 오른쪽으로 이동 -> 즉, 커서의 한 칸 오른쪽에 있던 문자가 커서의 왼쪽으로 이동하게 됨
        # 4) 대소문자인 경우
        else:
            left.append(s) # 항상 커서의 왼쪽에 위치
    print(''.join(left+right[::-1]))