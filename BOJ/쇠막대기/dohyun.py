"""

풀이시간
- 약 2시간

접근법
- 괄호만으로 어떻게 쇠 막대기가 잘린 것을 표현할 것인가?
    - 레이저의 괄호와 쇠막대기의 괄호 표기법이 똑같음 -> "()" 가 쪼개지는 형상으로 표현가능하지 않을까?
- 예시 
    - (()) -> ()()
    - (()()) -> ()()()
- 즉 큰 '()' 안에 들어있는(=막대기) 레이저('()') 의 개수 + 1 하면은 답임
- 위 생각에 근거해서 풀이 -> 답은 제대로 나오는 것 같은데 시간초과
- 문자열을 계속해서 생성해내는 알고리즘 때문에 시간초과가 나는 것 같음 
- 시간 너무 많이 써서 그냥 답 봄

회고
- 스택 자료구조에 대해서 모르고 있었던게 아닌데도 써먹을려고 하니까 어렵다 ㅠ ㅠ
    - 풀이 이해를 잘 못하겠서용 ... ㅜㅜ
- 초기풀이가 당연히 시간복잡도가 큰 풀이인데도 불구하고 혹시 모른다는 생각으로 계속 풀어보다가 시간 너무 낭비함
    - 저번에도 이런적이 꽤 있는데 의식하고 빨리 다른 풀이로 돌아갈 줄 알아야함 (제발)

"""

### 기존 풀이
import sys

text = sys.stdin.readline().strip()
stop_n = int((int(len(text)/2) + 1)/2) # "()" 로 쪼갰을 때 전부 "()()()()..." 가 되면 다 쪼개진거 -> "()()()..." 의 개수
ans = 0
n = 1

while text != '()'* stop_n: # 다 쪼개지면 멈춤
    cnt = 0 # 쪼개진 막대기 개수를 카운트하는 변수
    while text != text.replace("(" + "()"*n + ")", "()"*n, 1): # 더 이상 안 쪼개질 때 까지 (대부분 한 번만에 쪼개짐)
        cnt += text.count("(" + "()"*n + ")") # 쪼개지는 막대 개수
        text = text.replace("(" + "()"*n + ")", "()"*n) # 실제로 쪼개기
    ans += (n+1) * (cnt) # 쪼갠 막대 개수 * (쪼개진 막대기 개수)
    n += 1

print(ans)


### 스택 활용 풀이
import sys

text = sys.stdin.readline().strip()
answer = 0
stack = []

for i in range(len(text)):
    if text[i] == '(': # 스택 쌓기
        stack.append('(')
        
    else:
        if text[i-1] == '(': # ()라면 (를 pop하고 현재 스택에 들어있는 ( 수만큼 값을 더해준다.
            stack.pop()
            answer += len(stack)
            
        else:
            stack.pop() 
            answer += 1 # 끄트머리 막대기 부분을 더해준다

print(answer)