"""

풀이시간
- 1시간 풀이 후 실패로 답지 참고

접근법
- N 이 십만 이하 -> 최대 O(NlogN) 으로 접근
- 연속된 몇개의 수 -> 순서는 보존된 상태로 풀어내야함
- 부분합은 중복되는 계산이 굉장히 많음 -> DP로 해결해보자

- 틀린 풀이
    - 고르는 숫자의 개수(n) 에 대한 dp 테이블을 만들고 값으로는 최대값을 넣어보자
    - 여러 예제를 만들어본 결과 배열 내 최대값은 고정으로 들어가는 것 같음
        - dp[1] 에 가장 큰 수를 넣으면 가장 큰 수를 고정으로 넣은 것과 같음
        - 따라서 고르는 숫자의 개수가 1개 늘어나면 왼쪽에 하나 추가한거랑 오른쪽에 하나 추가한거 비교해서 더 큰것으로 선택
    - 의사 코드 (점화식?)
        ```
        left_sum = dp[i-1] + arr[left_idx - 1]
        right_sum = dp[i-1] + arr[right_idx + 1]
        dp[i] = max(left_sum, right_sum)
        left_idx 또는 right_idx 업데이트
        ```
    - 주어진 예제 외에도 테스트케이스를 10개 정도 만들어서 돌려봤는데도 잘 나오는데, 제출하면 틀림 ...

- 정답 풀이
    - 그냥 왼쪽부터 순회하며 이전값 + 현재값이 더 크면 연속합 갱신해주고, 현재값이 더 크면 이전 합들을 다 버리고 새로 시작하면 됨

회고
- DP 문제는 테이블 설정 또는 점화식 접근을 잘 못하는 순간 완전 잘못된 방향으로 가는 것 같다
    - 다른 유형들에 비해 특히나 더 사전에 생각을 많이하고 풀이 시작하기

"""

import sys

inputs = sys.stdin.readline
n = int(inputs())
arr = list(map(int, inputs().rstrip().split()))

for i in range(1, n):
    arr[i] = max(arr[i], arr[i-1] + arr[i])

print(max(arr))
