"""

풀이시간
- 1시간

접근법
- 사전 시간 복잡도 접근을 어떻게 해야할지 모르겠음..!!
- 최고의 집합이 존재하지 않는 경우는 n > s 인 경우밖에 없음
- 처음에는 모든 경우의 수를 구해서 곱을 갱신하는 방식으로 하려고 했음 -> 1시간 넘겨서 그냥 힌트보고 풀이
- 가장 큰 같은 숫자끼리 곱하는 것이 중요
    - n * n = n^2, (n-1)(n+1) = n^2-1, (n-2)(n+2) = n^2 - 4 , ... 
    - n * n * n = n^3, n-1 * n * n+1 = n^3-n, ...
    - 위와 같이 합이 n 이면 같은 숫자끼리 곱하는 것으로 가장 큰 값을 구할 수 있다!
- 몫과 나머지 연산을 통해 해결할 수 있음
    - 몫으로 모든 값들을 통일
    - 이후 순서를 고려해 나머지를 뒤에서부터 더해줌

회고
- 예시를 여러 개 들어보면서 같은 숫자를 곱하는 것, 큰 숫자를 곱하는것이 중요하다는 것은 눈치챘지만 몫과 나머지 연산을 생각 못했음
- 예시에서 규칙이 발생하면 그것에 집중해서 풀이하는 연습도 필요할 것 같다

"""

def solution(n, s):
    if n > s:
        return [-1]  # 최고의 집합이 존재하지 않는 경우
    
    quotient, remainder = divmod(s, n) # 몫과 나머지
    
    answer = [quotient] * n  # 몫으로 모든 배열을 채우면 가장 큰 숫자의 평균들로 채울 수 있음
    
    for i in range(n-1, n-1 - remainder, -1): # 순서를 고려해 뒤에서부터 나머지를 하나씩 더해줌
        answer[i] += 1  
        
    return answer


print(solution(n=2, s=9)) # [4, 5]
print('----------')
print(solution(n=2, s=1)) # [-1]
print('----------')
print(solution(n=2, s=8)) # [4, 4]
print('----------')
print(solution(n=3, s=5)) # [1, 2, 2]