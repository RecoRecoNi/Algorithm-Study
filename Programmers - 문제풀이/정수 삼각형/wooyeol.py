"""
    정수 삼각형
    https://school.programmers.co.kr/learn/courses/30/lessons/43105

    

    접근법
    무슨 알고리즘으로 풀이 할 수 있을까? -> 그리디를 떠올렸지만 단순한 조건이 아니기 때문에 DP로 풀이 시도
    
    - 삼각형의 상단 꼭지점에서부터 좌우의 선택을 하여 최대 합을 계산한다.

    # 다음의 숫자들은 계산되는 2차원 배열의 인덱스를 반환합니다.

    0
    0 1
    0 1 2
    0 1 2 3
    0 1 2 3 4

    # 1,2층
    0
    0 1
    0+0 0+1 : dp

    # 2,3층
    0 1
    0 1 2
    0+0 max(0+1,1+1) 1+2

    # 3,4층
    0 1 2
    0 1 2 3
    0+0 max(0+1,1+1) max(1+2,2+2), 2+3

    #4,5층
    0 1 2 3
    0 1 2 3 4
    0+0 max(0+1,1+1) max(1+2,2+2), max(2+3,3+3), 3+4

    다음의 과정을 통해 확인 할 수 있는 점화식은

    triangle[해당 층][데이터의 인덱스]
    triangle[전 층][같은 데이터의 인덱스]

    dp[해당 층][데이터의 인덱스] = max(dp[해당 층][데이터 인덱스]->이전에 계산된 값 , dp[전 층][데이터 인덱스] + triangle[해당 층][데이터 인덱스])
    dp[해당 층][다음 데이터의 인덱스] = max(dp[해당 층][다음 데이터 인덱스]->이전에 계산된 값 , dp[전 층][데이터 인덱스] + triangle[해당 층][다음 데이터 인덱스])
    가 반복되었을 때 모든 DP 테이블 계산을 진행 할 수 있게 된다.
    
    그렇다면 마지막 최대 DP 테이블 행의 최대 값이 실제 최대 값이다.

    다음의 값을 가지고 테스트 케이스의 DP 테이블을 계산한다면 다음과 같이 결과 값이 저장되어 있다.
    [[7], [0, 0], [0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0, 0]]
    [[7], [10, 15], [0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0, 0]]
    [[7], [10, 15], [18, 16, 15], [0, 0, 0, 0], [0, 0, 0, 0, 0]]
    [[7], [10, 15], [18, 16, 15], [20, 25, 20, 19], [0, 0, 0, 0, 0]]
    [[7], [10, 15], [18, 16, 15], [20, 25, 20, 19], [24, 30, 27, 26, 24]]
"""


def solution(triangle):
    height = len(triangle)

    # 높이가 5일때 DP Table 예시
    # {초기 값}
    # 0 0
    # 0 0 0
    # 0 0 0 0
    # 0 0 0 0 0

    dp = [[0] * (x + 1) for x in range(height)]

    # 초기 삼각형의 꼭짓점의 값은 그대로 첫 번째 행에 추가하기
    dp[0][0] = triangle[0][0]

    for r_id in range(height - 1):
        for c_id, _ in enumerate(triangle[r_id]):
            # 현재 행의 dp 테이블은 이미 계산되어 업데이트 된 값과 이전 층까지의 계산된 값에 현재 층과 같은 삼각형의 값을 더한 값 중 더 큰 값을 가지게 한다.
            dp[r_id + 1][c_id] = max(
                dp[r_id + 1][c_id], dp[r_id][c_id] + triangle[r_id + 1][c_id]
            )

            # 왼쪽과 오른쪽 두 가자 방향만을 가지기 때문에 좌우 두 가지 경우에 대해서만 계산을 진행한다.
            dp[r_id + 1][c_id + 1] = max(
                dp[r_id + 1][c_id + 1], dp[r_id][c_id] + triangle[r_id + 1][c_id + 1]
            )
        # print(dp)
    return max(dp[-1])


case1 = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]  # result = 30
print(solution(case1))
