"""
풀이시간: 18분

<제한사항>
- 삼각형의 높이는 1 이상 500 이하
- 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수

<solution>
DP의 가장 기본적인 유형
그리디로 풀 수 없는 이유는 매 번 가장 큰 수를 선택하는 것이 가장 큰 합을 만들 수 없기 때문!

1. 테이블 정의하기
D[i][j]: i번째 층의 j번째 위치에 올 수 있는 가장 큰 수

2. 점화식 찾기
    1) 가장 왼쪽에 있는 수(j == 0)
    - d[i][j] = d[i-1][j]
    2) 가장 오른쪽에 있는 수 (j == i)
    - d[i][j] = d[i-1][j-1]
    3) 안쪽에 있는 수들(1 <= j <= i-1)
    - d[i][j] = max(d[i-1][j-1], d[i-1][j])

    d[i][j] += triangle[i][j]

3. 초기값 정하기
d[0][0] = triangle[0][0]

<시간복잡도>
O(n^2)
- n은 최대 500이기 때문에 500 * 500 = 2,500으로 충분히 통과가능
"""


from typing import List

def solution(triangle: List) -> int:
    n = len(triangle)

    # 1. 테이블 정의
    d = [[0] * (level+1) for level in range(n)]
    # 2. 초기값 정하기
    d[0][0] = triangle[0][0]

    # 3. 점화식
    for i in range(1, n):
        for j in range(i+1):
            # 1) 가장 왼쪽에 있는 수
            if j == 0:
                d[i][j] = d[i-1][j]
            # 2) 가장 오른쪽에 있는 수
            elif j == i:
                d[i][j] = d[i-1][j-1]
            # 3) 안쪽에 있는 수들
            else:
                d[i][j] = max(d[i-1][j-1], d[i-1][j])
            d[i][j] += triangle[i][j]

    answer = max(d[n-1])
    return answer


triangle = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]
print(solution(triangle))


"""
정확성  테스트
테스트 1 〉	통과 (0.02ms, 10.2MB)
테스트 2 〉	통과 (0.03ms, 10.2MB)
테스트 3 〉	통과 (0.06ms, 10.2MB)
테스트 4 〉	통과 (0.20ms, 10.3MB)
테스트 5 〉	통과 (1.48ms, 10.4MB)
테스트 6 〉	통과 (0.45ms, 10.4MB)
테스트 7 〉	통과 (1.46ms, 10.5MB)
테스트 8 〉	통과 (0.32ms, 10.1MB)
테스트 9 〉	통과 (0.02ms, 10.4MB)
테스트 10 〉	통과 (0.19ms, 10.4MB)

효율성  테스트
테스트 1 〉	통과 (45.10ms, 17.9MB)
테스트 2 〉	통과 (34.41ms, 16.1MB)
테스트 3 〉	통과 (55.93ms, 18.8MB)
테스트 4 〉	통과 (44.57ms, 18MB)
테스트 5 〉	통과 (41.51ms, 17.2MB)
테스트 6 〉	통과 (52.64ms, 19.2MB)
테스트 7 〉	통과 (48.32ms, 18.6MB)
테스트 8 〉	통과 (41.16ms, 16.9MB)
테스트 9 〉	통과 (46.55ms, 17.4MB)
테스트 10 〉	통과 (56.48ms, 18.6MB)
"""