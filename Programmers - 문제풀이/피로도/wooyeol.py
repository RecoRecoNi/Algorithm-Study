"""
    피로도
    https://school.programmers.co.kr/learn/courses/30/lessons/87946

    던전의 갯수는 1이상 8이하 -> 완전 탐색으로도 가능하지 않을까?

    접근법
    무슨 알고리즘으로 풀이 할 수 있을까? -> DP or Greedy ? Nope 완전탐색
    
    - 던전의 갯수가 1~8이기 때문에 이는 완전 탐색으로 문제 풀이가 가능하다.

        - 실제 던전 갯수에 따른 연산 횟수
            1 * 1 = 1
            2 * 2 = 4
            6 * 3 = 18
            24 * 4 = 96
            120 * 5 = 600
            720 * 6 = 4320
            5040 * 7 = 35280
            40320 * 8 = 322560

"""
from itertools import permutations


def solution(k: int, dungeons: list):
    # 클리어 가능한 던전의 수 반환을 위한 answer
    answer: int = 0

    # 최대 8개의 던전의 모든 순열의 갯수만큼 확인해본다.
    for dungeon in permutations(dungeons):
        # 임시로 사용되는 피로도와 클리어 던전 갯수를 초기화
        temp_k, temp_answer = k, 0

        # 해당 순서로 던전을 탐색하였을 때 탐험 할 수 있는 던전의 갯수 세기
        for need, use in dungeon:
            if temp_k >= need:
                temp_answer += 1
                temp_k -= use

        # 최대 값보다 더 많이 던전을 탐색 할 수 있다면 해당 값으로 업데이트
        answer = max(temp_answer, answer)

    return answer


case1 = (80, [[80, 20], [50, 40], [30, 10]])
case2 = (80, [[50, 20], [50, 40], [30, 10]])

print(solution(*case1))
print(solution(*case2))

# 순열의 갯수
# 1
# 2
# 6
# 24
# 120
# 720
# 5040
# 40320

# 실제 던전 갯수에 따른 연산 횟수
# 1 * 1 = 1
# 2 * 2 = 4
# 6 * 3 = 18
# 24 * 4 = 96
# 120 * 5 = 600
# 720 * 6 = 4320
# 5040 * 7 = 35280
# 40320 * 8 = 322560


# 테스트 1 〉	통과 (0.02ms, 10.1MB)
# 테스트 2 〉	통과 (0.02ms, 10.2MB)
# 테스트 3 〉	통과 (0.06ms, 10.1MB)
# 테스트 4 〉	통과 (0.08ms, 10.3MB)
# 테스트 5 〉	통과 (0.46ms, 10MB)
# 테스트 6 〉	통과 (3.36ms, 10.1MB)
# 테스트 7 〉	통과 (31.57ms, 10.3MB)
# 테스트 8 〉	통과 (33.49ms, 10.1MB)
# 테스트 9 〉	통과 (0.06ms, 10.1MB)
# 테스트 10 〉	통과 (3.09ms, 10.3MB)
# 테스트 11 〉	통과 (0.02ms, 10.1MB)
# 테스트 12 〉	통과 (27.30ms, 10.1MB)
# 테스트 13 〉	통과 (29.69ms, 10MB)
# 테스트 14 〉	통과 (24.90ms, 10.2MB)
# 테스트 15 〉	통과 (23.00ms, 10.2MB)
# 테스트 16 〉	통과 (2.63ms, 10.3MB)
# 테스트 17 〉	통과 (31.18ms, 10.1MB)
# 테스트 18 〉	통과 (0.02ms, 10.1MB)
# 테스트 19 〉	통과 (0.12ms, 10.1MB)
