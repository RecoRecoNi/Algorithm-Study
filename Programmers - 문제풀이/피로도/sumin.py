"""
풀이시간: 10분

<제한사항>
- 각 던전은 하루에 한 번만 탐험이 가능하다 -> 하루 동안 최대한 많이 탐험하려고 한다.
- dungeons의 길이(즉, 던전의 개수)는 1 이상 8 이하이다.


<solution>
- dungeons의 길이가 최대 8이기 때문에, 모든 경우의 수를 확인하는 브루트 포스(완전탐색)으로 문제 풀이가 가능하다.
- 얼핏보면 그리디로 접근할 수 있나? 생각할 수 있지만, n(dungeons의 길이)이 매우 작고 몇 가지 그리디를 생각해봐도 반례가 무수히 많이 존재하기 때문에 그리디로 풀 수 없다.
    - 1) 매번 가장 적은 소모 피로도를 가진 던전부터 탐험 -> k = 80, dungeons=[[30, 10], [80, 20], [60, 30]] -> 1개(정답은 3개) 
    - 2) 매번 가장 큰 최소 필요 피로도를 가진 던전부터 탐험 -> 문제의 예시와 동일
    기타 등등

<시간복잡도>
dungeons의 길이는 최대 8로 연산횟수는 최대 8! = 40320으로 시간 내에 충분히 통과가 가능하다.

dungeons의 모든 순열(permutations)을 만들면 최대 8! = 40320이며
각 순열마다, 던전들을 반복하며 now와 cnt 값을 계산하기 때문에 모든 순열에 대해 O(n)이 걸린다.

따라서, 전체적으로 솔루션의 시간 복잡도는 O(n * n!)로 최대 8 * 8! = 322560의 연산횟수를 갖지만 충분히 시간 내에 통과 가능하다.


<번외>
이 문제는 어떤 던전부터 방문할 것인지 '순서'가 중요하고 순열을 임의의 수열을 다른 '순서'로 섞는 연산이기 때문에 순열로 풀이가 가능하다.
마찬가지로 permuations 라이브러리를 사용하지 않고, next_permutation을 구현해서 풀 수도 재귀를 이용해 풀 수도 있다.
"""

from itertools import permutations
from typing import List

def solution(k:int, dungeons:List) -> int:
    answer: int = -1  # 유저가 탐험할 수 있는 최대 던전 수
    for permu in permutations(dungeons):
        now = k  # 현재 피로도 초기화
        cnt = 0  # 유저가 탐험할 수 있는 던전의 수 초기화
        for need, use in permu:  # 모든 경우의 수
            if now >= need:  # 현재 피로도 >= 최소 필요 피로도로 해당 던전 탐험 가능
                now -= use  # 해당 던전을 탐험 -> 현재 피로도 - 소모 피로도
                cnt += 1  # 탐험한 던전 수 갱신
        if cnt > answer:  # 탐험한 던전 수가 지금까지 탐험할 수 있는 최대 던전 수보다 클 때만 갱신
            answer = cnt

    return answer


"""
테스트 1 〉	통과 (0.01ms, 10.5MB)
테스트 2 〉	통과 (0.01ms, 10.5MB)
테스트 3 〉	통과 (0.04ms, 10.5MB)
테스트 4 〉	통과 (0.13ms, 10.5MB)
테스트 5 〉	통과 (0.39ms, 10.5MB)
테스트 6 〉	통과 (4.94ms, 10.7MB)
테스트 7 〉	통과 (26.58ms, 10.6MB)
테스트 8 〉	통과 (26.19ms, 10.6MB)
테스트 9 〉	통과 (0.09ms, 10.6MB)
테스트 10 〉통과 (3.18ms, 10.7MB)
테스트 11 〉통과 (0.02ms, 10.5MB)
테스트 12 〉통과 (25.53ms, 10.5MB)
테스트 13 〉통과 (19.08ms, 10.6MB)
테스트 14 〉통과 (19.43ms, 10.7MB)
테스트 15 〉통과 (16.58ms, 10.6MB)
테스트 16 〉통과 (3.44ms, 10.5MB)
테스트 17 〉통과 (30.41ms, 10.6MB)
테스트 18 〉통과 (0.01ms, 10.6MB)
테스트 19 〉통과 (0.09ms, 10.7MB)
"""