"""
시간복잡도: O(nlogn)
풀이시간: 35분
targets의 길이가 500,000인 걸보고, 최대 O(nlogn)으로 해결해야겠다고 생각했음.
전형적인 그리디 문제. 백준의 회의실 배정, 강의실 배정과 유사해서 정렬 및 그리디를 생각함

1. 끝지점을 기준으로 오름차순 정렬해준다.
2. targets(폭격 미사일 리스트)의 원소를 하나씩 확인하면서 요격미사일 설치지점이 s(시작지점)보다 작은지 확인한다.
3. 이전에 설치한 요격 미사일이 현재 확인하고 있는 폭격 미사일의 시작지점보다 작다면 해당 폭격 미사일을 요격할 수 없기 때문에
- 미사일을 추가로 설치한다.
- 요격 미사일의 위치를 현재 폭격 미사일의 끝지점으로 갱신한다.
"""
def solution(targets):
    answer = 0
    targets.sort(key=lambda x: x[1]) # e를 기준으로 오름차순 정렬
    missile = -1 # s, e는 0이상이니까 -1로 초기화

    for s, e in targets: # 폭격 미사일의 s,e 좌표
        if missile < s: # 이전 미사일로 현재 폭격 미사일을 요격할 수 없으면
            answer += 1 # 미사일 추가
            missile = e-0.1 # 요격 미사일은 실수인 x좌표에서 발사가능(s와 e에서 발사하는 요격미사일로는 요격할 수 없음)
    return answer


"""
[[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]] -> 3
[[0, 4], [1, 2], [1, 3], [3, 4]] - >2
[[0, 4], [0, 1], [2, 3]] -> 2
"""
targets = [[0, 4], [1, 2], [1, 3], [3, 4]]
print(solution(targets))